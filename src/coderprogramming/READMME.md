## 读书笔记

### 1.如何终止正在运行的线程？

1.使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。
2.使用stop方法强制终止线程，但是不推荐使用这个方法，因为stop和suspend及resume一样，都是作废过期的方法，使用它们可能产生不可预料的结果。
3.使用Interrupt方法中断线程。


### 2.线程中this.interrupted()与this.isInterrupted方法之间有什么区别？

1.this.interrupted()：测试当前线程是否已经是中断状态，执行后具有将状态标识置清除为false的功能。
2.this.isInterrupted：测试线程是否已经中断，但不清楚状态标志。


### 3.线程中，yield()方法的作用是什么？

作用：放弃当前的CPU资源，将它让给其他的任务去占用CPU执行时间，但放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片。

### 4.如何设置线程优先级？介绍一下？

- 设置线程优先级使用setPriority()方法。优先级一共分为1~10级，如果小于1或者大于10，则JDK抛出异常throw new IllegalArgumentException();
- 线程的优先级具有继承性，比如A线程启动B线程，则B线程的优先级与A是一样的。
- 当线程优先级的等级差距很大时，谁先执行完和代码的调用顺序无关。
- 优先级较高的线程不一定每一次都先执行完。
- 线程优先级与打印顺序无关，它们之间的关系具有不确定性和随机性。

### 5.什么是守护线程？

在Java线程中有两种线程，一种是用户线程，另外一种是守护线程。
守护线程是一种特殊的线程，它的特性有"陪伴"的含义，当进程中不存在非守护线程了，则守护线程自动销毁。典型的守护线程就是垃圾回收线程，当进程中没有非守护线程了，则垃圾回收线程也就没有存在的必要了，自动销毁。
用个比较通俗的比喻来解释一下"守护线程"：任何一个守护线程都是整个JVM中所有非守护线程的"保姆"，只要当前JVM实例中存在任何一个非守护线程没有结束，守护线程就在工作，只有当最后一个非守护线程结束时，守护线程才随着JVM一同结束工作。守护线程最典型的应用就是GC(垃圾回收器)，它就是一个很称职的守护者。


### 本章小结

本章主要介绍了Thread类的API，在使用这些API的过程中，会出现一些意想不到的情况，其实这也是多线程具有不可预知性的一个体现。


---

### 1.方法内的变量是否为线程安全的？

“非线程安全”问题存在于“实例变量”中，如果是方法内部的私有变量，则不存在“非线程安全”问题，所得结果也就是“线程安全”的了。这是因为方法内部的变量时私有的特性造成的。如果两个线程同时操作业务对象中的实例变量，则可能会出现"非线程安全"的问题。因此要对访问的方法加synchronized进行同步设置。

关键字synchronized取得的锁是什么锁？
关键字synchronized取得的锁都是对象锁，而不是把一段代码或者方法(函数)当做锁，哪个线程先执行带synchronized关键字的方法，哪个线程就持有该方法所属对象的锁Lock，那么其他线程只能呈等待状态，前提是多个线程访问的是同一个对象。如果多个线程访问多个对象，则JVM会创建多个锁。

### 2.什么情况下需要同步化？
只有共享资源的读写访问才需要同步化，如果不是共享资源，那么根本就没有同步的必要。
